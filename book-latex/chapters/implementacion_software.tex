%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Generic template for TFC/TFM/TFG/Tesis
%
% $Id$
%
% By:
%  + Javier Macías-Guarasa.
%    Departamento de Electrónica
%    Universidad de Alcalá
%  + Roberto Barra-Chicote.
%    Departamento de Ingeniería Electrónica
%    Universidad Politécnica de Madrid
%
% Based on original sources by Roberto Barra, Manuel Ocaña, Jesús Nuevo,
% Pedro Revenga, Fernando Herránz and Noelia Hernández. Thanks a lot to
% all of them, and to the many anonymous contributors found (thanks to
% google) that provided help in setting all this up.
%
% See also the additionalContributors.txt file to check the name of
% additional contributors to this work.
%
% If you think you can add pieces of relevant/useful examples,
% improvements, please contact us at (macias@depeca.uah.es)
%
% Copyleft 2013
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Desarrollo software}
\label{cha_implementacion_sofware}

\begin{FraseCelebre}
  \begin{Frase}
TODO
La imaginación es más importante que el conocimiento. El conocimiento es limitado y la imaginación circunda el mundo.    
  \end{Frase}
  \begin{Fuente}
Albert Einstein, en \emph{The Saturday Evening Post}
  \end{Fuente}
\end{FraseCelebre}


El desarrollo software del robot de Eurobot se organiza en capas o módulos funcionales, de forma que aquellos de nivel superior implementan funciones más abstractas que los inferiores. De mayor a menor nivel de abstracción, son las siguientes:

\begin{enumerate}
\item Estrategia de juego
\item Temática del juego
\item Sistemas mecánicos
\item Plataforma robótica base
\end{enumerate}

El módulo \emph{plataforma robótica} incluye las funcionalidades de desplazamiento, localización y evitación de obstáculos. Al mismo nivel, se encuentra el módulo \emph{sistemas mecánicos} encargado de controlar los mecanismos utilizados por el robot para manipular los elementos de juego. Ambos módulos se integran y se sincronizan en la capa de \emph{temática del juego} para implementar funcionalidades propias de la temática de Eurobot. Por último, la capa \emph{estratégia de juego} decide cuando y que acciones del juego realizar en cada momento para jugar un partido de Eurobot.

Así por ejemplo, si la capa de estrategia decide recolectar el tomate 1 llama a funciones del tipo \texttt{harvest\_tomato(TOMATO\_1)} de la capa de temática de juego, la cual a su vez utilizará funciones de la plataforma robótica del tipo \texttt{goto\_avoid\_xy(TOMATO\_1\_X, TOMATO\_1\_Y)} para moverse evitando los obstáculos hacia la posición del tomate 1 y, funciones de los sistemas mecánicos del tipo \texttt{system\_tomatoes\_set\_mode(MODE\_HARVEST)} para recolectar el tomate mediante el sistema mecánico de recolección de tomates.


\section{Librerias Aversive y Aversive4dspic}

La implementación SW de los robots se ha realizado a partir de las librerías Aversive \cite{aversive_src}, desarrolladas por el equipo de Eurobot Microb Technology \cite{microb}. Las librerías Aversive constituyen un marco de trabajo para el desarrollo de sistemas basados en microcontroladores AVR de Atmel. 

Las librerías Aversive4dspic son una migración de las librerías Aversive a microcontroladores dsPIC de Microchip, utilizados por en el HW desarrollado para los robots. Para realizar la migración de las librerías Aversive ha sido necesario desarrollar la capa de \emph{drivers de dispositivos HW} dependiente directamente del microcontrolador dsPIC, manteniendo las interfaces de los drivers equivalentes de microcontroladores AVR. Además ha sido necesario migrar dependencias específicas del compilador utilizado por las plataformas AVR al equivalente en el compilador para dsPICs. 

Las librerías Aversive4dspic mantienen la compatibilidad hacia atrás y permiten trabajar también con plataformas AVR. El código nuevo desarrollado o las modificaciones de código existente ha sido realizadas siguiendo la misma convención de código de las librerías originales.

Las librerías Aversive utilizan un \emph{toolchain} basado en la herramienta \texttt{make}. Así, a partir de un fichero \texttt{makefile} es posible configurar el proyecto para utilizar los módulos necesarios de la librería, especificar los ficheros de código fuente, compilar el código fuente y programar el microcontrolador. Además de soportar la compilación cruzada para microcontroladores AVR, estas librerías soportan la compilación y ejecución en \emph{HOST} para plataformas GNU/Linux.

Respecto las librerías Aversive4dspic, soportan la creación de un proyecto y configuración de los módulos a utilizar mediante la herramienta \texttt{make} y la compilación en \emph{HOST}. La compilación cruzada para microcontroladores dsPIC y su programación se realiza mediante el entorno de desarrollo de Microchip MPlab y MPlabX.

Las estructura de las librerías se divide en 5 carpetas principales:

\begin{itemize}
\item \textbf{\texttt{config}}: ficheros relacionados con la configuración de las librerías.

\item \textbf{\texttt{include}}: ficheros de cabecera generales, no relacionados con los módulos de la librería.

\item \textbf{\texttt{mk}}: ficheros \texttt{makefiles} de las librerias (proyecto, módulos y plantillas)

\item \textbf{\texttt{modules}}: módulos de la librería. Un módulo es una pequeña librería con una funcionalidad específica.

\item \textbf{\texttt{projects}}: ejemplos de proyecto.
\end{itemize}

Los módulos se encuentran organizados en las siguientes carpetas:

\begin{itemize}
\item \textbf{\texttt{modules/base}}: módulos comunes y frecuentemente utilizados.
\item \textbf{\texttt{modules/comm}}: módulos de comunicación (UART, SPI, I2C, ...).
\item \textbf{\texttt{modules/cryto}}: módulos para operaciones de cifrado de datos.
\item \textbf{\texttt{modules/debug}}: módulos de ayuda a la depuración.
\item \textbf{\texttt{modules/devices}}: módulos de dispositivos específicos no dependientes del HW del microcontrolador (LCDs, motores, ...).
\item \textbf{\texttt{modules/encoding}}: módulos de codificación (base 64, \emph{hamming}, ...).
\item \textbf{\texttt{modules/hardware}}: módulos de interfaces del microcontrolador (\emph{timers}, ADC, ...).
\item \textbf{\texttt{modules/ihm}}: módulos de interfaz hombre-maquina (menues, interfaz de comandos, ...)
\end{itemize}

Algunos módulos incluyen una configuración previa a la compilación. En estos casos, los módulos tienen asociado un fichero de cabecera de configuración con el formato \texttt{nombre\_modulo\_config.h}. Estos ficheros se encuentran en la carpeta \texttt{config} de cada módulo. Durante la configuración de un proyecto Aversive, estos ficheros son copiados a la carpeta raíz del proyecto, donde pueden ser modificados para ajustar la configuración a las necesidades del proyecto.

Por otro lado, cada uno de los módulos de la librerías incluye un proyecto de prueba. Este proyecto sirve para probar el correcto funcionamiento del módulo durante su desarrollo y como ejemplo de uso para aprender a utilizarlo. Los proyectos de prueba se encuentran en la carpeta \texttt{test} de cada módulo.

De cara a la implementación SW del robot de Eurobot (o cualquier sistema embebido), cada capa funcional utiliza ciertos módulos de la librería de funcionalidad muy específica. Sin embargo, hay algunos módulos que se utilizan transversalmente a todas las capas y que implementan funcionalidades comunes y útiles a todas ellas. Las siguientes secciones describen estas funcionalidades y los módulos utilizados en su implementación.

\subsection{Herramientas matemáticas}

La librería incluye varios módulos matemáticos que permiten realizar operaciones matemáticas en punto fijo o con objetos como polígonos y vectores:

\begin{itemize}
\item \textbf{\texttt{modules/base/math/fixed\_point}}: operaciones matemáticas en punto fijo.
\item \textbf{\texttt{modules/base/math/geometry}}: operaciones con puntos, lineas, polígonos y círculos.
\item \textbf{\texttt{modules/base/math/vect2}}: operaciones con vectores.
\end{itemize}

Estos módulos son utilizados por ejemplo para la implementación sistemas de control en punto fijo, o en la implementación de evitación de obstáculos del robot, donde cada obstáculo es representado por un polígono.

\subsection{Gestión de \emph{buffers} de datos}

Es muy común que para la implementación de interfaces de comunicación (UART, I2C, SPI, ...) se necesiten \emph{buffers} donde almacenar los datos que van a ser transmitidos o que se han recibido. Para ello puede utilizarse el módulo \textbf{\texttt{modules/comm/cirbuf}} que permite crear y gestionar buffers de datos circulares. 

\subsection{Planificador de eventos}

El módulo \textbf{\texttt{modules/base/scheduler}} implementa un planificador de eventos con prioridad. Los eventos pueden ser periódicos o eventuales, lo primeros llevan asociado un periodo y los segundos un instante de ejecución a partir del momento de creación.

El módulo \emph{scheduler} está pensado para ejecutarse en la interrupción de un \emph{timer}, el periodo de dicho \emph{timer} constituye el periodo base del \emph{scheduler} (por ejemplo 1ms). Cada periodo se evalúa que evento ejecutar. Dado que los eventos se ejecutan en un contexto de interrupción las funciones asociadas a estos han de ser de corta duración y no bloqueantes.

Mediante eventos del \emph{scheduler} el robot implementa por ejemplo la lectura de sensores cada 10ms, los sistemas de control cada 5ms o los protocolos de comunicación con la baliza o el robot secundario cada 10ms.  

\subsection{Medida de tiempo}

El módulo \textbf{\texttt{modules/base/time}} permite medir de tiempo del sistema. Este módulo se ejecuta como un evento del \emph{scheduler} y su periodo de ejecución se corresponde con la resolución de medida del tiempo. Permite obtener el tiempo transcurrido desde su inicialización en horas, minutos, segundos y microsegundos. 

Este módulo permite implementar esperas bloqueantes o no bloqueantes. Por ejemplo, a los 90 segundos los robots han de dejar de jugar y desactivar todos los sistemas. Esta espera se puede implementar de forma precisa a partir de este módulo evaluando periódicamente el número de segundos transcurridos desde el inicio de partido.  

\subsection{Mensajes de depuración}

El módulo \textbf{\texttt{modules/debug/error}} implementa mensajes de depuración o \emph{logs} que permiten trazar el funcionamiento del software implementado con el fin de verificar su correcta ejecución. Cada mensaje tiene asociado un número de error y un nivel de gravedad: EMERG, ERROR, WARNING, NOTICE y DEBUG. 

El módulo permite definir la función a partir de cual los mensajes son generados para cada nivel de gravedad. En dicha función se define el formato de los mensajes, la información de estos y la interfaz por la cual son transmitidos (UART, SPI, I2C, etc.). 

El software desarrollado para los robots y los módulos de las librerías utilizan el módulo \emph{error}. En este caso, la función que genera los mensajes utiliza la salida estándar (conectada a una UART) para transmitir los mensajes. Esta función, además, filtra los mensajes por número de error y nivel de gravedad, de forma que sólo aquellos mensajes con números de error habilitados y de nivel de gravedad superior al establecido serán transmitidos, con la excepción de los mensajes de nivel ERROR que serán siempre transmitidos.


\subsection{Interfaz de linea comandos}

Las librerías permiten implementar una interfaz de linea comandos similar a la de sistemas GNU/Linux con las siguientes características:

\begin{itemize}
\item Interfaz de comunicación serie configurable (UART, I2C, SPI, ...).
\item Caracteres imprimibles y no imprimibles VT100.
\item Ayuda/información de cada comando.
\item Completado automático de argumentos y sugerencia del tipo de argumento a introducir.
\item Tipo de argumentos: texto (\emph{strings}), números enteros (8 y 16 bits) y números decimales (\emph{float}). 
\item Comprobación de número argumentos y tipo de los argumentos.
\item Histórico de comandos ejecutados
\end{itemize}

La interfaz de linea de comandos se implementa a partir de los siguientes módulos:

\begin{itemize}
\item \textbf{\texttt{modules/ihm/vt100}}: módulo que permite interpretar los caracteres no imprimibles VT100.
\item \textbf{\texttt{modules/ihm/rdline}}: módulo de lectura de una linea, terminada en retorno de carro, a través de una interfaz serie de entrada, por ejemplo una UART.
\item \textbf{\texttt{modules/ihm/parse}}: módulo que realiza la correlación de una linea con los posibles comandos a ejecutar y sus argumentes, y en caso de coincidencia, ejecuta el comando correspondiente.
\end{itemize}

Los módulos \texttt{rdline} y \texttt{parse} utilizan el módulo \texttt{vt100} para poder interpretar los caracteres no imprimibles como el tabulador o los cursores. Por ejemplo, el tabulador es utilizado para completar un argumento tipo texto o para indicar el tipo del argumento siguiente. Por otro lado, los cursores permiten moverse por el listado de comandos ejecutados o por una linea escrita para modificarla.

El módulo \emph{parse} tiene asociado una lista de comandos y cada comando tiene asociado unos parámetros de entrada y una función a ejecutar. A medida que \emph{rdline} recibe una linea utiliza información del la lista de comandos de \emph{parse} para implementar el completado de argumentos de texto o indicar el tipo del siguiente argumento. Si el comando y sus argumentos coinciden con alguno de los comandos de la lista de comandos, el módulo \emph{parse} ejecuta la función asociada al comando, propagando los argumentos introducidos por la línea de comandos a dicha función.

En el caso del desarrollo software del robot de Eurobot, la interfaz de linea de comandos constituye la capa de mayor nivel, más abstracta y la interfaz entre el robot y sus desarrolladores. La linea de comandos está presente durante todo el desarrollo del robot e implementa comandos mediante los cuales controlar o probar el funcionamiento de las diferentes capas o niveles del software. Así, hay comandos que permiten controlar directamente el HW del robot, como la generación de señales PWM o la lectura del valor de sensores, o comandos muchos más abstractos que permiten mover el robot hasta una posición (x,y) del campo o iniciar un partido de Eurobot.

 
\section{Arquitectura software}

La arquitectura SW desarrollada se definió en el año 2010 durante el desarrollo del robot Tropetero. Por aquel entonces sólo se competía con un robot por equipo, más tarde, en el año 2014 la arquitectura evolucionó hacia la competición con dos robots por equipo. 

La figura \ref{fig_sw_diagrama_bloques} muestra el diagrama de bloques SW de un equipo de dos robots: un robot principal y uno secundario. Ambos robots implementan la misma arquitectura SW diferenciándose únicamente en el número de elementos implicados en la implementación. Debido a la complejidad de los sistemas mecánicos del robot principal, éste implementa la arquitectura mediante dos microcontroladores, mientras que el robot secundario utiliza un único microcontrolador. Además, la baliza tipo faro del robot principal constituye un sistema independiente, mientras que la baliza del robot secundario se encuentra integrada en la arquitectura HW y SW del robot. 

\begin{figure}[ht]
\centering
\includegraphics[width=\textwidth]{sw_diagrama_bloques}
\caption[]{Diagrama de bloques software del robot principal y secundario}
\label{fig_sw_diagrama_bloques}
\end{figure}

Cada robot tiene una interfaz serie que permite acceder a la linea de comandos de cada uno utilizando un terminal serie de un ordenador. En el caso del robot principal, utiliza una interfaz serie RS-232, mientras que el robot secundario utiliza una interfaz serie Bluetooth (perfil SPP, \emph{Serial Port Profile}).

Ambos robots y la baliza del robot principal se encuentran conectados mediante sendos canales serie Bluetooth. Estos canales son utilizados para implementar el protocolo de comunicación entre el robot principal y la baliza, y entre el robot principal y el robot secundario. También es posible utilizar estos canales Bluetooth para acceder a la linea de comandos de la baliza y del robot secundario desde el terminal serie del ordenador, a partir de un \emph{bypass} de los datos en el robot principal.

Igualmente, ambos robots utilizan una interfaz I2C maestro-esclavo para acceder a dispositivos de expansión de E/S, a los que se encuentran conectados sensores. Además, en el caso del robot principal, esta interfaz es utilizada por el microcontrolador principal para comunicarse con el microcontrolador esclavo (SLAVE DSPIC), el cual implementa el control de sistemas mecánicos. Mediante la interfaz I2C se implementa un protocolo de mensajes que permite compartir la información de los dispositivos conectados al bus (sensores) con ambos microcontroladores y, una gestión de los sistemas mecánicos por parte del microcontrolador principal. 

Por otro lado, como se puede observar en la figura \ref{fig_sw_diagrama_bloques}, la arquitectura SW de cada robot se organiza en las siguientes capas y módulos funcionales:

\begin{description}
\item \textbf{Drivers de dispositivos HW}

Esta capa permite abstraer los módulos o dispositivos HW del robot, como módulos de comunicación del microcontrolador (UART, I2C, SPI, ...) o dispositivos externos a éste como servomotores, o drivers en puente en H para el control de motores. Éste nivel  trabaja, por ejemplo, con funciones del tipo \texttt{uart\_send(UART0, dato)} para transmitir un dato por la UART numero 0, o \texttt{pwm\_mc\_set(OUT1,-1000} para fijar el valor y sentido del motor conectado al la salida OUT1 a -1000. 

\item \textbf{Plataforma robótica base}

Módulo que implementa las funcionalidades de la plataforma robótica base: control de posición, odometría, gestión de trayectorias y evitación de obstáculos. Implementa funciones del tipo \texttt{robot\_goto\_xy(1000, 500)} para ir al punto (x=1000, y=500), o  \texttt{robot\_get\_xy()} para obtener la coordenada (x,y) del robot.

\item \textbf{Sistemas mecánicos}

Módulo que abstrae el control de los diferentes sistemas mecánicos del robot mediante los cuales se manipulan los elementos del  juego. Éste módulo trabaja con funciones del estilo \texttt{system\_tomatoes\_set\_mode(HARVEST)} (configura el sistema de tomates en modo recolección), o  como \texttt{system\_tomatoes\_get\_num()} (obtener el número de tomates recolectados).

\item \textbf{Temática del juego}

Esta capa permite abstraer completamente las funcionalidades de la plataforma robótica y de los sistemas mecánicos e integra la información de la baliza. De esta forma, a este nivel se trabaja con funciones que sincronizan los movimientos del robot con los sistemas mecánicos, como \texttt{harvest\_tomato(TOMATO\_1)} (ir hasta la posición del tomate 1 y recolectarlo).

Esta capa también tiene funciones que integran la información de varios módulos, como la información de odometría, del tiempo transcurrido, de la baliza y de los sensores de obstáculos. Es el caso de la función \texttt{wait\_traj\_end(END\_TRAJ|END\_TIMER|END\_OBSTACLE)} que esperar el fin de una trayectoria debido a diferentes razones: \emph{punto destino alcanzado}, \emph{tiempo de partido se acaba}, o por \emph{obstáculo en el camino encontrado}.


\item \textbf{Estrategia de juego}

Esta capa implementa la estrategia de juego de un partido así como las diferentes fases de las que se compone un partido. Las funciones esperadas a este nivel son del tipo \texttt{is\_the\_opponent\_in\_zone(ZONE\_TOMATOES\_1)} (¿está el oponente en la zona de los tomates?), o \texttt{goto\_zone(ZONE\_TOMATOES\_1)} (ir a la zona de los tomates), o \texttt{work\_on\_zone(ZONE\_TOMATOES\_1)} (trabajar en la zona de los tomates).

Como se puede observar en la \ref{fig_sw_diagrama_bloques}, la capa \emph{estrategia de juego} no se encuentra implementada en el robot secundario. Esto es debido a que la estrategia se encuentra centralizada en el robot principal y, es éste, el que decide en todo momento lo que le corresponde hacer al robot secundario. 

\item \textbf{Linea de comandos}

La linea de comandos permite ejecutar comandos de cualquier módulo o nivel. De esta forma durante el desarrollo de las diferentes capas o módulos, las funcionalidades de éstas pueden ser probadas por partes y verificar su correcto funcionamiento. Por ejemplo a nivel estrategia el comando \texttt{init yellow}, inicializa los robots para jugar en el lado amarillo del campo de juego. Y mediante el comando \texttt{start qualification match}, se ejecuta un partido con la estrategia diseñada para la fase de clasificación de una competición de Eurobot.

\end{description}

Respecto al módulo \emph{sistemas mecánicos} a su vez se encuentra dividido en varias capas o módulos, como se representa en el diagrama de capas del microcontrolador esclavo del robot principal (ver figura \ref{fig_sw_diagrama_bloques}), el cual, implementa únicamente el control de los sistemas mecánicos. Aclarar, que en el caso del robot secundario estas capas se encuentra integradas en un único microcontrolador. 

Las capas y módulos de los que se compone la implementación SW de los sistemas mecánicos son las siguientes: 

\begin{description}
\item \textbf{Sensores}

Módulo encargado de la adquisición y procesamiento de los sensores de los sistemas mecánicos (finales de carrera, medidores de distancia, detectores de color, etc.). Este módulo implementa funciones del tipo \texttt{sensor\_get(SENSOR1)} para, por ejemplo, leer el estado del sensor numero 1.

\item \textbf{Actuadores}

Módulo de control de los actuadores de los mecanismos (servomotores, motores, electroválvulas, etc). Este módulo implementa funciones del tipo \texttt{ax12\_set\_pos(AX12\_ID\_1, 512)} (mover el servomotor AX12 a la posición 512).

\item \textbf{Control de mecanismos}

Esta capa abstrae e integra los actuadores y sensores que forman mecanismos funcionales. Por ejemplo, un mecanismo puede ser un brazo robótico formado por varios servomotores y una pinza, o un clasificador de tomates compuesto por un palo movido por un servomotor. De esta forma se utilizan funciones del tipo \texttt{arm\_goto\_xy()} para llevar al brazo a una coordenada, o funciones como \texttt{tomatoes\_clasiffier\_set\_pos(SIDE\_LEFT)} para clasificar un tomate hacia el lado izquierdo.

\item \textbf{Control de sistemas mecánicos}

Esta capa gestiona los diferentes mecanismos de los que se compone un sistema mecánico, e implementa los diferentes modos de funcionamiento de éste. Por ejemplo, un sistema mecánico puede ser el sistema de recolección de tomates. Éste sistema puede estar compuesto por un mecanismo de clasificación de tomates, un sensor detector de presencia de tomates, un mecanismo de almacenamiento y un mecanismo de liberación de los tomates recolectados. El sistema, por ejemplo, puede trabajar en modo \emph{recolectar} o \emph{liberar tomates} y, permite \emph{clasificar} los tomates rojos y verdes. Dependiendo del modo de funcionamiento se han de utilizar unos mecanismos u otros.

La forma más común de implementar esta capa es mediante máquinas de estado. Por ejemplo, la maquina de estados del ejemplo anterior puede corresponderse con la función \texttt{do\_syytem\_tomatoes(uint8\_t mode, uint8\_t tomato\_type)}, la cual permite hacer funcionar el sistema de recolección de tomates en sus diferente modos de funcionamiento (parámetro \texttt(mode)), y elegir el tipo de tomate (parámetro \texttt{tomato\_type}).  

\end{description}


\section{Implementación software}

\subsection{Drivers de dispositivos HW}

Incluye los siguietes modulos desarrollados

%\subsection{UART}
%\subsection{I2C}
%\subsection{SPI}
%\subsection{PWM servo}
%\subsection{PWM motor control}
%\subsection{DAC motor control}
%\subsection{Encoders dsPIC}


\subsection{Plataforma robótica base}

\begin{figure}[p]
\centering
\includegraphics[width=.9\textwidth]{sw_diagrama_plataforma_robotica}
\caption[]{Diagrama de organización y funcionamiento SW de la plataforma robótica base}
\end{figure}

\subsubsection{Control de posición}
\subsubsection{Odometría}
\subsubsection{Detección de bloqueos}
\subsubsection{Gestión de trayectorias}

\subsection{Tematica del robot}
[actuators | sensors | cs] > [strat (base, utils, avoid)] | [Interfaz baliza] | [Interfaz secondary robot]  

\subsection{Estrategia de juego}
[tareas secondary robot] | [tareas main robot] > [trayectorias a zonas | trabajo en zonas] > [estrategias partido]
%		\subsection{Estrategias de partido}
%			\subsubsection{Estrategia secuencial bloqueante}
%			\subsubsection{Estrategia reactiva}
%			\subsubsection{Estratégia basada en prioridades}
%			\subsubsection{Estratégia adaptativa}
%			\subsubsection{Estrategia con dos robots}


\section{Simulador de robots}

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{sw_diagrama_bloques_simulador}
\caption[]{Diagrama de bloques software del simulador de robots y campo de juego}
\end{figure}


%%% Local Variables:
%%% TeX-master: "../book"
%%% End:
